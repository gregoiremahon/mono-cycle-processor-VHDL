library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity processingUnit is
    port (
        clk, rst: in std_logic;
        instruction: in std_logic_vector(31 downto 0);
        dataOut: out std_logic_vector(31 downto 0)
    );
end entity processingUnit;

architecture behavior of processingUnit is

-- Input signals for the Register Bank
signal regWrite : std_logic_vector(3 downto 0);
signal regAddrA : std_logic_vector(3 downto 0);
signal regAddrB : std_logic_vector(3 downto 0);
signal regDataIn : std_logic_vector(31 downto 0);
signal regDataA : std_logic_vector(31 downto 0);
signal regDataB : std_logic_vector(31 downto 0);

-- Output signals for the ALU
signal aluOp : std_logic_vector(1 downto 0);
signal aluDataA : std_logic_vector(31 downto 0);
signal aluDataB : std_logic_vector(31 downto 0);
signal aluDataOut : std_logic_vector(31 downto 0);
signal aluNegative : std_logic;


begin

-- Instantiate the Register Bank and ALU
registerBank_inst : entity work.banc_registres
    port map (
        clk => clk,
        rst => rst,
        w => regDataIn,
        ra => regAddrA,
        rb => regAddrB,
        rw => regWrite,
        we => regWrite /= "0000", -- correction
        a => regDataA,
        b => regDataB
    );

alu_inst : entity work.UAL
    port map (
        op => aluOp,
        a => aluDataA,
        b => aluDataB,
        s => aluDataOut,
        n => aluNegative
    );

-- Control signals for the Register Bank
regWrite <= instruction(15 downto 12);
regAddrA <= instruction(11 downto 8);
regAddrB <= instruction(7 downto 4);
regDataIn <= instruction(3 downto 0);

-- Control signals for the ALU
aluOp <= instruction(27 downto 26);
aluDataA <= regDataA;
aluDataB <= regDataB;

-- Control signal for Data Out
dataOut <= aluDataOut;

end architecture behavior;